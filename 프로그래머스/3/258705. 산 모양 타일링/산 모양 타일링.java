class Solution {
    
    private static final int CONSTANT = 10007;
    
    public int solution(int n, int[] tops) {
        int answer = 0;
        int[][] dp = new int[n][2];
        
        if (tops[0] == 0) {
            dp[0][0] = 2;
            dp[0][1] = 1;
        }
        
        if (tops[0] == 1) {
            dp[0][0] = 3;
            dp[0][1] = 1;
        }
        
        for (int i = 1; i < n; i++) {
            
            if (tops[i] == 0) {
                dp[i][0] = 2 * dp[i-1][0] + dp[i-1][1];
                dp[i][1] = dp[i-1][0] + dp[i-1][1];
            }
            
            if (tops[i] == 1) {
                dp[i][0] = 3 * dp[i-1][0] + 2 * dp[i-1][1];
                dp[i][1] = dp[i-1][0] + dp[i-1][1];
            }
            
            dp[i][0] %= CONSTANT;
            dp[i][1] %= CONSTANT;
        }
        
        return (dp[n - 1][0] + dp[n - 1][1]) % CONSTANT;
    }
}
/**
n 1~10만
n 1,2,3,..10만
  3,5,7..200_001개의 정삼각형이 주어지게 되며, 모두 아랫변이 더 긴 사다리꼴 모양이다.

### 구현
dp하면 되겠다.
맨 마지막 정삼각형이 마름모에 포함되었는지 여부에 따라 경우의 수를 누적시킬 수 있다.
dp[n][2] : 2(n+1)+1개의 받침 삼각형이 있을때, 맨 오른쪽 정삼각형이 마름모영역일때[1]/아닐때[0]의 모든 경우의 수

1. tops[0]이 1인지 0인지에 따라 dp[0][0], dp[0][1]을 구한다.
2. 1~n까지 순회하면서 2n번째의 정삼각형위에 얹혀진 삼각형의 존재 여부에따라 dp값을 갱신한다.

### 점화식

1. n == 1
1-1) tops[0] = 0;
- 정삼각형 3개 -> 1가지 (1)
- 마름모타일 1개 + 삼각형 1개 -> 2가지 (2n)
=> 3가지
--> 여기서 마지막 정삼각형이 정삼각형인 경우는 2가지이다. (c1)
--> 그리고 마지막 정삼각형이 마름모로 채워져 있는 경우는 1가지이다. (c2)

::n == 2로 이동할때, tops[1] = 0
next_c1 = 4(c1*2) + 1(c2) = 5
next_c2 = 2(c1) + 1(c2) = 3

::n == 2로 이동할때, tops[1] = 1
next_c1 = 6(c1*3) + 2(c2*2); = 8
next_c2 = 2(c1) + 1(c2); = 3

정리하자면,
tops[n - 1] == 0 일떄
- dp[n][0] = 2 * dp[n-1][0]+ dp[n-1][1];
- dp[n][1] = dp[n-1][0] + dp[n-1][1];

tops[n - 1] == 1 일때
- dp[n][0] = 3 * dp[n-1][0] + 2 * dp[n-1][1];
- dp[n][1] = dp[n-1][0] + dp[n-1][1];


그리고 맨 첫 시작점 dp값은 대해서,

tops[1 - 1] == 0
- c1 = 2
- c2 = 1

tops[1 - 1] == 1
- c1 = 1 + 1 + 1 =3
- c2 = 1 = 1

dp[1][1]

*/